// utils
import { handleError } from "@/utils/handle-errors.js";
import { sanitizePath } from "@/utils/sanitize-path.js";
import { intro, log, outro, spinner, tasks } from "@clack/prompts";
import { Command } from "commander";
import fg from "fast-glob";
import fs from "fs/promises";
import micromatch from "micromatch";
import path from "path";
import prettier from "prettier";
import { z } from "zod";

// schema
export const generateRegistrySchema = z.object({
	cwd: z.string(),
	dir: z.string(),
	output: z.string(),
	extension: z.enum(["none", "ts", "js", "tsx", "jsx"]),
	dry: z.boolean(),
	recursive: z.boolean(),
	format: z.enum(["named", "default"]),
	prettify: z.boolean(),
	ignore: z.array(z.string()),
});

export const registry = new Command()
	.name("registry")
	.description("Generate a registry file based on files in a directory")
	.alias("r")
	.option("-c, --cwd <cwd>", "Working directory")
	.option("-d, --dir <dir>", "Directory to scan for files", ".")
	.option("-o, --output <output>", "Output file", "registry.ts")
	.option("-e, --extension <extension>", "File extension to include", "none")
	.option("-D, --dry", "Dry run mode (no write)", false)
	.option("-r, --recursive", "Include subdirectories", false)
	.option("-f, --format <format>", "Export format: 'named' or 'default'", "named")
	.option("-p, --prettify", "Prettify output", false)
	.option("-i, --ignore <patterns...>", "Ignore patterns", [])
	.action(async (opts) => {
		intro("Minager - Generate registry");
		const s = spinner();
		s.start("Validating options...");

		const parsed = generateRegistrySchema.safeParse({
			cwd: path.resolve(opts.cwd ?? process.cwd()),
			dir: sanitizePath(opts.dir),
			output: sanitizePath(opts.output),
			extension: opts.extension,
			dry: opts.dry,
			recursive: opts.recursive,
			format: opts.format,
			prettify: opts.prettify,
			ignore: opts.ignore,
		});

		if (!parsed.success) return handleError(parsed.error);

		s.stop("Options validated successfully");

		await tasks([
			{
				title: `Generating registry file in ${parsed.data.output}`,
				task: async () => {
					await generateRegistry(parsed.data);
					return parsed.data.dry ?
							"Registry printed to console."
						:	`Registry written to ${parsed.data.output}`;
				},
			},
		]);

		outro(parsed.data.dry ? "Dry run complete" : "Registry generation finished.");
	});

type RegistryOptions = z.infer<typeof generateRegistrySchema>;

async function detectExportName(filePath: string): Promise<string | null> {
	const content = await fs.readFile(filePath, "utf8");
	const match = content.match(/export\s+(?:const|function|class)\s+(\w+)/);
	return match?.[1] ?? null;
}

async function generateRegistry({
	cwd,
	dir,
	output,
	dry,
	extension,
	format,
	prettify,
	ignore,
	recursive,
}: RegistryOptions) {
	const absCwd = path.resolve(cwd);
	const ignorePatterns = ignore.map((p) => p.replace(/\\/g, "/"));
	const supportedExts = ["ts", "tsx", "js", "jsx"];

	const matchedDirs = await fg(sanitizePath(dir), {
		cwd: absCwd,
		onlyDirectories: true,
		absolute: true,
		unique: true,
		dot: false,
	});

	if (matchedDirs.length === 0) {
		log.message(`No directories matched: ${dir}`);
		return;
	}

	const outputFileName = path.basename(output);
	const outputIsGlob = output.includes("*");

	for (const dirPath of matchedDirs) {
		const lines: string[] = [
			"// This file is auto-generated by Mingull's Minager CLI",
			"// Do not edit manually",
			'import { createLibraryRegistry } from "@mingull/registry";',
			"",
			format === "default" ?
				"export default createLibraryRegistry({"
			:	"export const registry = createLibraryRegistry({",
		];

		const fileList: string[] = [];

		const walk = async (folder: string) => {
			const entries = await fs.readdir(folder, { withFileTypes: true });
			for (const entry of entries) {
				const fullPath = path.join(folder, entry.name);
				const relPath = path.relative(dirPath, fullPath).replace(/\\/g, "/");

				if (micromatch.isMatch(relPath, ignorePatterns)) continue;
				if (entry.isDirectory()) {
					if (recursive) await walk(fullPath);
				} else if (
					entry.isFile() &&
					(extension === "none" ?
						supportedExts.includes(path.extname(entry.name).slice(1))
					:	path.extname(entry.name).slice(1) === extension) &&
					!entry.name.endsWith(".d.ts") &&
					!entry.name.startsWith("index.")
				) {
					fileList.push(relPath);
				}
			}
		};

		await walk(dirPath);

		if (fileList.length === 0) {
			log.message(`No valid files found in ${dirPath}`);
			continue;
		}
		const finalOutputPath = outputIsGlob ? path.join(dirPath, outputFileName) : path.join(absCwd, output);

		for (const file of fileList) {
			const absFile = path.join(dirPath, file);
			const exportName = await detectExportName(absFile);
			if (!exportName) throw new Error(`No export found in: ${file}`);

			const importPath = `./${path.relative(path.dirname(finalOutputPath), absFile).replace(/\\/g, "/")}`;
			lines.push(`\t${exportName}: () => import("${importPath}").then(mod => mod.${exportName}),`);
		}

		lines.push("});", "");
		const content = lines.join("\n");

		if (dry) {
			log.message(`Preview for ${finalOutputPath}`);
			lines
				.filter((line) => line.trim() !== "")
				.filter((line) => !line.startsWith("//"))
				.slice(0, 15)
				.forEach((line, i) => log.message(`${i + 1}. ${line}`));
			if (lines.length > 15) log.message(`... and ${lines.length - 15} more lines`);
		} else {
			const formatted = prettify ? await prettier.format(content, { filepath: finalOutputPath }) : content;
			await fs.mkdir(path.dirname(finalOutputPath), { recursive: true });
			await fs.writeFile(finalOutputPath, formatted, "utf-8");
		}
	}
}
